## 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

---

상속을 고려한 설계와 문서화란?

- 메서드를 재정의하면 어떤 일이 일어나는지를 정확히 정리하여 문서로 남겨야 한다.
내부적으로 **self-use 하는지 문서로 기록**하자

<aside>

재정의 가능이란?

`public` 과 `protected` 메서드 중 final 이 아닌 모든 메서드를 뜻한다.

</aside>

API 문서의 메서드 설명 끝에서 종종 “Implementation Requirements”로 시작하는 절을 볼 수 잇는데, 그 메서드의 내부 동작을 설명하는 곳이다.

→ 만약 어떤 메서드를 재정의한다면 부모 클래스에  `Implementation Requirements` 부분이 있는지 참고하는 습관을 가지자

책에서는 “좋은 API 문서란 ‘어떻게’ 가 아닌 ‘무엇’을 하는지 설명해야 한다” 라는 말과 대조된다고 언급과 함께 **상속만 아니었다면 기술하지 않았어야 할** 내부 구현 방식을 설명해야만 한다고 말한다.

→ 좋은 API 문서와 상속을 위한 좋은 API 문서는 다르다 정도로 기억하자

### **하지만 내부 매커니즘을 문서로 남기는 것만이 상속을 위한 설계의 전부는 아니다!!!**

효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 **클래스의 내부 동작 중간에 끼어들 수 있는 훅을 잘 선별하여 protected 메서드 형태로 공개해야 할 수 도 있다.** 드물게는 protected 필드로 공개해야 할수도 있다.

글로만 봤을 때 무슨 의미인지 잘 이해가 되지 않는다.

예시 사례로 `java.util.AbstractList` 의 removeRange() 메서드 예시가 나온다

요약하자면 `fromIndex`  부터 `toIndex` 까지의 모든 원소를 리스트에서 제거한다.

toIndex 이후의 원소들은 앞으로 index 만큼 당겨지는 방식으로 구현됨을 설명하고 이로 인해 
성능 저하가 발생할 수 있음을 알려준다.

→ 그래서 중간에 끼어들 수 있는 Hook과 protected는 무슨 의미일까?

책의 예시와 동일하게`java.util.AbstractList`  로 예시를 든다면 해당 리스트는 하위 구현체로 인해 `ArrayList` 또는 `LinkedList` 형태로 구현될 수 있다.

하지만 `AbstractList` 를 추상화하는 시점에서는 어떤 하위 클래스가 `removeRange()` 모르기에 
해당 글을 참고하고 각자의 맞도록 재정의 하도록 알려주는 것이다.

근데 **여기서 중간에 끼어들 수 있는?** 이라는 말에 대한 의문이 풀리지 않았다.

→ 나의 이해는 중간에 끼어들 수 있는 = self use 를 의미하는 것 같다.

왜냐하면 자바를 사용하면서 `list.clear()` 방식으로 리스트를 초기화를 해본 경험이 있을거다.

리스트 자료주고를 `clear()` 메서드를 이용해서 초기화는 과정이고 이 메서드는 아래와 같이 구현되어 있다.

```sql
public void clear() {
    // 내부적으로 removeRange를 호출해서 처음부터 끝까지 다 지움
    removeRange(0, size());
}
```

clear 내부에서 `removeRange()` 를 호출하는 방식으로 self use 하는 방식이다.

따라서 클라이언트는 `clear()` 를 재정의하는 것이 아닌 `Implementation Requirements`  를 참고해서 `removeRange()` 를 재정의해야 한다.

마지막으로 이를 ArrayList와 같은 배열 형태의 리스트 구조가 구현한다면 `removeRange()` 를 원소를 지우고 당기는 방식이 아닌 각 값을 null 값을 할당하는 등의 O(N) 시간에 초기화 가능하다.

그래서 “중간에 끼어들 수 있는 Hook과 protected는 무슨 의미일까?” 라는 질문의 결론은

self use로 사용되면서 하위 구현체의 특성에 맞도록 재정의 되어야하는 메서드를 Hook이라고 부르고  이를 Hook이라는 의도에 맞게 상속 받는 구현체에서만 사용하도록  `protected` 접근 제한자로 지정하자 

### 어떤 메서드를 protected로 노출해야 할까?

아쉽게도 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일하다고 한다.

꼭 필요한 `proetected` 멤버를 놓쳤다면 하위 클래스를 작성할 때 그 빈자르가 확연히 드러난다. 또한, 하위 클래스를 여러 개 만들 때 까지 전혀 쓰이지 않는 `protected` 멤버는 사실 `private` 일 가능성이 높다.

<aside>

상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증하자

</aside>

## 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.

직접 코드를 보고 이해하는 것이 가장 빠르다.

```java
public class Super {
	//잘못된 예
	public Super() {
		overrideMe();
	}
	
	public void overrideMe() {}
	
}
```

상위 클래스는 이렇게 만들어두었고 하위 클래스에서 overrideMe 메서드를 재정의하며 오동작을 확인하자

```java
public final class Sub extends Super {
	private final Instant instant;
	
	Sub() {
	 instant = Instant.now();
	 }
	 
	 // 재정의
	 @Override
	 public void overrideMe() {
		 System.out.println(instant);
		}
}

/// 싫행하기
 public static void main(String[] args) {
     Sub sub = new Sub();
     sub.overrideMe();
   }
 }
 
```

이 프로그램은 instant를 두 번 출력할 것 을 기대하지만 

첫번째는 null 을 출력한다.

상위 클래스의 생성자는 하위 클래스의 생성자가 인스턴스 필드를 초기화하기도 전에 overrideme를 호출하기 때문이다!

### Cloneable과 Serializable 인터페이스는 상속용 설계의 어려움을 준다.

`clone` 과 `readObject` 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.

라고 책에서 말한다.

→ 이 내용은 위에서 했던 말과 똑같은데 왜 이 두가지만 더 강조를 할까?

`clone()` 과 `readObject()` 는 생성자와 동일한 역할을 수행하는 메서드이기 때문이다.

그래서 생성자와 똑같은 제약을 받아야 하는데, 이를 인지하지 않아 실수하기 쉽다.

결과적으로 이곳도 동일하게 `Cloneable`과 `Serializable`을 구현할 때, `clone`이나 `readObject` 메서드 안에서는 절대 `private`이나 `final`이 아닌 다른 메서드를 부르지 않으면 된다.

## 상속을 금지하는 방법 두가지

1. 클래스를 final로 선언하라
2. 모든 생성장를 `private` 이나 `package-private` 으로 선언하고 정적 팩터리를 만든다

### 최종 결론

self use 하는 메서드가 있다면 상속하지 않는 것이 좋다.

만약 그런 구분있다면 다른 item에서 말한 18 번 방식 또는 hook 요소인지 판단해서 
문서화하여 상속 클래스를 만들어라