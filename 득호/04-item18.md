# 18. 상속보다는 컴포지션을 사용하라

## 상속의 문제점
메서드 재정의를 통해 부모 클래스의 동작을 수정하려 할 때, 내부 구현 방식(Self-use 등)을 정확히 알지 못하면 의도치 않은 버그(예: 카운트 중복 증가)가 발생한다.

Self-use를 해결하기 위한 접근 방법
1. 하위 클래스에서 부모 메서드를 재정의하지 않는다.
2. self-use를 피하기 위해 다른 방식으로 재정의한다.

### self-use 문제 예시
```java
public class InstrumentedSet<E> extends HashSet<E> {
	private int addCount = 0;

	@Override
	public boolean add(E e) {
		addCount++;
		return super.add(e);
	}

	@Override
	public boolean addAll(java.util.Collection<? extends E> c) {
		addCount += c.size();
		return super.addAll(c); //부모의 addAll 호출
	}

	public int getAddCount() {
		return addCount;
	}
}

// HashSet의 addAll내부 구현
public boolean addAll(Collection<? extends E> c) {
        boolean modified = false;
        for (E e : c)
            if (add(e)) // 내부적으로 add() 메서드를 호출
                modified = true;
        return modified;
    }
 ```
**[문제상황]**

HashSet을 상속 받아 addAll() 메서드를 사용하는 경우 부모 클래스에서 정의해둔 로직에 강하게 결합된다.
이로 인해 `@Override` 를 통해 개발자가 의도했던 방식과는 다르게 작동할 수 있는 경우가 발생한다.

- 다형성으로 인한 오류

  메서드는 다형성의 대상이기 때문에 객체의 실제 타입을 기준으로 가장 하위에서 재정의된 메서드를 찾아서 실핸다.

  따라서  하위 클래스에서 super를 호출하도록 재정의한다면 상위 클래스까지 전파되지만 super를 호출하지 않는 형태로 오버라이딩 한다면 자식 타입의 메서드가 실행되는 결과를 볼 수 있다.

    ```text
      하지만 필드는 오버라이딩 대상이 아니기에 super 명령어로 호출된 부모 클래스에서
      하위 클래스에서 재정의한 필드 멤버를 사용하더라도 부모 클래스의 필드에 저장된 값으로 사용된다.
    
      따라서 필드의 다형성을 활용하고 싶다면 private으로 선언하고  getter, setter 방식을 사용하면된다.
    ```

한계: 코드를 수정해 당장의 문제를 해결한다 해도, 하위 클래스는 여전히 상위 클래스의 내부 구현에 강하게 결합되어 있다.
이러한 이유로 상위 클래스가 변경되면 하위 클래스가 깨질 위험이 있다. (보안 취약점 발생)

## 해결 방법 : 컴포지션 설계
이 문제를 해결하기 위해 'is-a 관계(상속)'가 아닌 'has-a 관계(컴포지션)'로 설계를 변경한다.

기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 하는 방식이다.

이때 extends를 사용하더라도 중간 확장을 위해 설계된 추상 클래스 또는 책에서 소개하는 래퍼타입의 클래스면 괜찮다.

### 구조
1. 래퍼 클래스 : 새로운 클래스는 기존 클래스를 감싸는 역할을 한다.
2. 전달 : 새 클래스의 메서드들은 복잡한 로직을 직접 수행하지 않고, private 필드로 가진 기존 클래스 인스턴스에게 요청을 그대로 전달하여 결과를 반환한다.

상속 대신 컴포지션 사용
---
```java
public class InstrumentedSet<E> extends ForwardingSet<E> {

	private int addCount = 0;

	public InstrumentedSet(Set<E> s) {
		super(s);
	}

	@override
	public boolean add(E e) {
		addCount++;
		return super.add(e);
	}

	@Override
	public boolean addAll(Collection<? extends E> c) {
		addCount += c.size();
		return super.addAll(c);
	}
}
```

재사용할 수 있는 전달 클래스
---
```java
public class ForwardingSet<E> implements Set<E> {
private final Set<E> s;
public ForwardingSet (Set<E> s) { this.s = s; }

// private 필드 s에 요청을 전달하는 메서드들
```

### 컴포지션의 장점
1. 결합도 제거: 내 클래스는 기존 클래스의 인터페이스만 알면 된다. 내부 구현이 어떻게 바뀌든(addAll이 add를 부르든 말든) 내 코드는 영향받지 않는다
2. 유연성 : 상속은 컴파일 시점에 부모가 정해지지만, 컴포지션은 런타임에 다른 구현체로 인스턴스를 교체하기 쉽다.
3. 캡슐화 : API 통제: 부모 클래스의 원하지 않는 메서드를 외부에 노출시키지 않고, 내가 원하는 API만 제공할 수 있다.

### 주의사항
SELF 문제: 내부 객체는 자신을 감싸고 있는 래퍼의 존재를 모른다. 따라서 콜백(Callback) 프레임워크 등에서 내부 객체가 자기 자신(this)을 넘기면, 래퍼의 로직이 무시될 수 있다.

스프링부트에서 Self - invocation 문제와 유사한 것 같다.