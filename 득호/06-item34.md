# 34 - int 상수 대신 열거 타입을 사용하라

자바에서 열거 타입을 지원하기 전에는 정수 상수를 한 묶음으로 선언해서 아래와 같이 사용했다.

```java
// 정수 열거 패턴
public static final int APPLE_FUJI = 0;
public static final int APPLE_PIPPIN = 1;

public static final int ORANGE_NAVEL = 0;
public static final int ORANGE_BLOOD = 1;
```

위와 같이 사용하는 정수 열거 패턴 기법에는 몇가지 문제가 있다.
1. 타입 안전을 보장할 방법이 없다.
2. 표현력이 좋지 않다.
3. 오렌지를 건네야 할 메서드에 사과를 보내고 동등 연산자를 비교하더라도 컴파일러는 아무런 경고를 줄 수 없다.
4. APPLE_ 과 같은 접두어를 써서 구분해야 한다.
5. 같은 정수 열거 그룹에 속한 모든 상수를 한 바퀴 순회하는 방법이 없다.
6. 정수 상수는 문자열로 출력하기가 까다롭다.

정수 대신 문자열 상수를 사용하는 변형 패턴도 있지만 여전히 타입 안전성, 표현력, 접두어 문제는 해결되지 않는다.

추가적으로 문자열 상수의 값을 외워 실수하는 경우가 발생할 수 있다.
```java
public class Country {
    // 개발자가 쓰라고 만들어둔 문자열 상수 (변수명)
    public static final String KOREA = "KR";
    public static final String USA = "US";
    public static final String JAPAN = "JP";
}

// ❌ 나쁜 코드 (값을 외움)
// 변수명(Country.KOREA)을 안 쓰고, 값("KR")을 직접 타이핑함
// 또한 문자열 비교는 문자열 비교에 따른 성능 저하 문제도 발생
if (user.getCountryCode().equals("KR")) {
applyKoreanDiscount();
}

// ✅ 좋은 코드 (변수명 사용)
if (user.getCountryCode().equals(Country.KOREA)) {
    applyKoreanDiscount();
}
```

## 열거 타입 사용
열거 타입이란 일정 개수의 상수 값을 정의한 다음, 그 외의 값은 허용하지 않는 타입이다.
```java
public enum Apple {FUJI, PIPPIN, GRANNY_SMITH}
```

열거 타입 자체는 클래스이며, 상수 하나당 자신의 인스턴스를 하나씩 만들어 `public static fianl` 필드로 공개한다.
```java
System.out.println(Apple.FUJI);
System.out.println(Apple.PIPPIN);
```

열거 타입은 밖에서 접근할 수 있는 생성자를 제공하지 않으므로 사실상 `final` 이다.

클라이언트가 인스턴스를 직접 생성하거나 확장할 수 없기에 열거 타입의 인스턴스들은 딱 하나만 존재한다.

따라서 열거 타입은 싱글턴을 일반화한 형태라고 볼 수 있다.

- 열거 타입은 컴파일타임 타입 안정성을 제공한다.
- 열거 타입에는 각자의 이름공간이 있다.
- 열거 타입에 새로운 상수를 추가하거나 순서를 바꿔도 다시 컴파일하지 않아도 된다.
- 열거 타입의 `toString()` 은 출력하기 적합한 문자열을 내어준다.
- 열거 타입은 임의의 메서드나 필드를 추가할 수 있고 인터페이스를 구현할 수 있다.
- 열거 타입은 Object 메서드들을 높은 품질로 구현해놨고, Comparable과 Serializable 인터페이스를 구현했다.
    - `toString()`, `equals()`, `hashCode()`, `compareTo()`, `valueOf()` 등

### 열거 타입에 메서드나 필드를 추가할 수 있다! 언제 사용하는가?
각 상수와 연관된 데이터를 해당 상수 자체에 내재시키고 싶은 경우

조금 더 쉬운 이해를 위해 Enum을 정의하는 코드를 보자

```java
public enum Planet {
    MERCURY (3.302e+23, 2.439e6),
    VENUS (4.869e+24, 6.052e6),
    EARTH (5.975e+24, 6.378e6),
    MARS (6.419e+23, 3.393e6),
    JUPITER (1.899e+27, 7.149e7),
    SATURN (5.685e+26, 6.027e7),
    URANUS (8.683e+25, 2.556e7),
    NEPTUNE (1.024e+26, 2.477e7);
	
    private final double mass; // 질량(단위: 킬로그램)
    private final double radius;// 반지름(단위: 미터)
    
    private final double surfaceGravity; // 표면중력(단위: m / s^2)
    private static final double G = 6.67300E-11; // 중력상수(단위: m^3 / kg 5^2)
    
    // 생성자
    Planet (double mass, double radius) {
        this.mass = mass;
        this. radius = radius;
        surfaceGravity = G * mass / (radius * radius);
    }
    public double mass ( ) { return mass; }
    public double radius() { return radius; }
    public double surfaceGravity() { return surfaceGravity; }

// Ex Planet.EARTH.surfaceWeight(175) : 175kg인 사람의 지구에서의 무게
    public double surfaceWeight (double mass) {
        return mass * surfaceGravity; // F =ma
    }
	
}
```

- 열거 타입 상수 각각을 특정 데이터와 연결지으러면 생성자에서 데이터를 받아 인스턴스 필드에 저장하면 된다.
- 이때 열거 타입은 근복적으로 불변이라 `final` 필드로 선언해야 한다.
- 필드를 `public`으로 선언해도 되지만, `private`으로 두고 별도의 public 접근자 메서드를 두는 게 낫다.
- 열거 타입은 자신 안에 정의된 상수들의 값을 배열에 담아 반환하는 `values()` 라는 정적 메서드를 자동으로 제공한다.
이를 통해 모든 상수를 순회할 수 있다.

  - 추가적으로 열거 타입은 내부 상수가 수정되어 삭제되는 경우에는 클라이언트가 
  삭제된 열거 타입을 직접 명시해서 사용하는 경우 컴파일 오류가 발생한다.
  하지만 이때 바람직한 예외를 발생 시켜 클라이언트가 문제를 인지하는 것이 쉽다. (정수 열거 패턴은 불가능)
      ```java
      public enum PaymentMethod {
      CARD,
      // TRANSFER,  <-- (삭제!) 더 이상 지원 안 함
      CASH
      }
      ```
      Enum PaymentMethod에서는 TRANSFER 상수가 삭제되었지만 실수로 클라이언트 코드에서 삭제하지 않는 경우
      ```java
      public void processPayment(PaymentMethod method) {
      // 🚨 컴파일 오류 발생! 
      // "Cannot find symbol: variable TRANSFER"
      if (method == PaymentMethod.TRANSFER) { 
          System.out.println("계좌이체를 진행합니다.");
      }}
    ```
     개발자는 즉시 컴파일 오류를 보고 문제를 인지할 수 있다.

      하지만 정수 열거 패턴의 경우 TRANSFER 상수를 삭제해도 컴파일 오류가 발생하지 않을 수 있음
      ```java
    public class PaymentMethod {
            public static final int CARD = 0;
            // public static final int TRANSFER = 1; <-- (삭제!)
            public static final int CASH = 2; 
        }
    
    public void processPayment(int method) {
        // 😱 열거 패턴의 경우 컴파일러는 'PaymentMethod.TRANSFER'를 이미 숫자 '1'로 바꿔(인라인) 놨음.
    
        if (method == 1) {  // 숫자 1로 하드 코딩되어 있음
          // 서버에는 1번(계좌이체)이 없는데,
          // 클라이언트는 혼자서 계속 "1번 결제해주세요"라고 요청을 보냄.
          System.out.println("계좌이체를 진행합니다.");
      }}
    ```
  
- 열거 타입의 기능을 클라이언트에 노출해야 할 합당한 이유가 없다면 `private` 혹은 `package-private` 으로 선언하자.
  

- 열거 타입은 상수별로 다르게 동작하는 코드를 구현할 수 있다.

    switch 문을 사용하지 않고도 상수별로 다른 동작을 구현할 수 있다.
    `apply()` 추상 메서드를 선언하고, 각 상수에서 이를 구현하도록 하면 된다.
    ```java
    public enum Operation {
        PLUS("+") {public double apply(double x, double y) { return x + y; }},
        MINUS("-") {public double apply(double x, double y) { return x - y; }},
        TIMES("*") {public double apply(double x, double y) { return x * y; }},
        DIVIDE("/") {public double apply(double x, double y) { return x / y; }};
        
        private final String symbol;
        
        Operation(String symbol) {
            this.symbol = symbol;
        }
        public abstract double apply(double x, double y);
    }
    ```
  이를 통해 각 상수에서 자신에 맞게 재정의하는 방식을 사용할 수 있다.
  이러한 방식을 사용하는 경우 실수로 누락한 경우 컴파일 오류를 통해 조기 식별 가능

- 열거 타입의 `toString()` 활용 방식
    ```java
      public enum Operation {
          PLUS("+") {public double apply(double x, double y) { return x + y; }},
          MINUS("-") {public double apply(double x, double y) { return x - y; }},
          TIMES("*") {public double apply(double x, double y) { return x * y; }},
          DIVIDE("/") {public double apply(double x, double y) { return x / y; }};
        
          private final String symbol;
        
          Operation(String symbol) {
              this.symbol = symbol;
          }
  
          @Override
          public String toString() {
              return symbol;
          }
        
          private static final Map<String, Operation> stringToEnum = new HashMap<>();
        
          static {
              for (Operation op : values()) {
                  stringToEnum.put(op.toString(), op);
              }
          }
         //  메서드를 재정의하려거든 fromString() 메서드도 함께 제공하자
          public static Operation fromString(String symbol) {
              return stringToEnum.get(symbol);
          }
        
          public abstract double apply(double x, double y);
      }
  ```
      

- 열거 타입의 정적 필드 중 열거 타입의 생성자에서 접근할 수 있는 것은 상수 변수뿐이다.
  - 열거 타입 생성자가 실행되는 시점에는 정적 필드들이 아직 초기화되기 전이라, 자기 자신을 추가하지 못하게 하는 제약이 꼭 필요하다.
    이 제약의 특수한 예로, 열거 타입 생성자에서 같은 열거 타입의 다른 상수에도 접근할 수 없다.
  - 열거 타입의 각 상수는 해당 타입의 인스턴스를 `public static final` 필드로 공개하는 것과 같다.
    따라서 열거 타입 생성자에서 같은 열거 타입의 다른 상수에 접근하는 것은 마치 자기 자신을 초기화하는 도중에 자기 자신을 참조하는 것과 같다.
    이는 허용되지 않는다.

- 전략 열거 타입 패턴
  - 전략 열거 타입을 사용하지 않는 경우 (switch 문 사용)
    ```java
    public enum PayrollDay {
        MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY,
        SATURDAY, SUNDAY;
    
        int pay(int minutesWorked, int payRate) {
            int basePay = minutesWorked * payRate;
    
            int overtimePay;
            switch (this) {
                case SATURDAY: case SUNDAY:
                    overtimePay = 0;
                    break;
                default: // 주중
                    overtimePay = minutesWorked <= MINS_PER_SHIFT ? 0
                            : (minutesWorked - MINS_PER_SHIFT) * payRate / 2;
            }
            return basePay + overtimePay;
        }
    
        static final int MINS_PER_SHIFT = 8 * 60;
    }
    ```
    코드 자체는 간결하고 직관적으로 보이지만, 새로운 값을 추가하거나 동작을 변경할 때마다 switch 문을 수정해야 한는 번거로움이 존재하고
    만약 switch 문이 누락되는 경우 런타임 오류가 발생할 수 있다.
    
  - 상수별로 다른 동작을 구현하는 열거 타입을 전략 패턴처럼 활용하는 방법이다.
  
    ```java
    public enum PayrollDay {
        MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY,
        SATURDAY(PayType.WEEKEND), SUNDAY(PayType.WEEKEND);
    
        private final PayType payType;
    
        PayrollDay() {
            this.payType = PayType.WEEKDAY;
        }
    
        PayrollDay(PayType payType) {
            this.payType = payType;
        }
    
        int pay(int minutesWorked, int payRate) {
            return payType.pay(hoursWorked, payRate);
        }
    
		// 전략 열거 타입
        private enum PayType {
            WEEKDAY {
                int pay(int minutesWorked, int payRate) {
                    int basePay = minutesWorked * payRate;
                    int overtimePay = minutesWorked <= MINS_PER_SHIFT ? 0
                            : (minutesWorked - MINS_PER_SHIFT) * payRate / 2;
                    return basePay + overtimePay;
                }
            },
            WEEKEND {
                double pay(int minutesWorked, int payRate) {
                    return minutesWorked * payRate * 2;
                }
            };
    
            abstract int pay(int minutesWorked, int payRate);
            static final int MINS_PER_SHIFT = 8 * 60;
        }
    }
    ```
    - 위 예제에서 `PayrollDay` 열거 타입은 요일별로 급여를 계산하는 `pay()` 메서드를 제공한다.
    - 평일과 주말에 따라 급여 계산 방식이 다르므로, `PayType`이라는 내부 열거 타입을 정의하여 각 요일에 맞는 급여 계산 로직을 구현했다.
    - 이를 통해 각 요일에 대한 급여 계산 로직을 명확하게 분리하고 관리할 수 있고 불필요한 중복을 피할 수 있다.

- 하지만 기존 열거 타입에 상수별 동작을 혼합해 넣을 때는 switch 문이 좋은 선택이 될 수 있다.
  - 여기서 혼합해 넣는다는 것은 기존 Enum을 건드리지 말고, 밖에서 클라이언트가 필요한 기능만 살짝 추가해서 사용하라는 것을 의미한다.
    - 외부 라이브러리의 Enum을 수정할 수 없는 경우를 예로 들 수 있다.
  - 상수별로 동작을 구현하는 방식은 상수마다 별도의 익명 클래스가 생성되므로 메모리 사용량이 늘어난다.