# 스트림에서는 부작용 없는 함수를 사용하라

스트림 패러다임의 핵심은 계산을 일련의 변환으로 재구성하는 부분이다.  
이 때 각 변환 단계는 가능한 한 이전 단계의 결과를 받아 처리하는 순수 함수여야 한다.
> [!info]+ 순수 함수란  
> 오직 입력만이 결과에 영향을 주는 함수를 말한다.  
> 다른 가변 상태를 참조하지 않고, 함수 스스로도 다른 상태를 변경하지 않는다.

이러한 순수 함수를 만들기 위해서는 스트임 연산에 건네는 함수 객체는 모두 side effect가 없어야 한다.

```java  
// 스트림 패러다임을 이해하지 못한 나쁜 코드  
Map<String, Long> freq = new HashMap<>();  
try (Stream<String> words = new Scanner(file).tokens()) {  
    words.forEach(word -> {        words.forEach(word -> {          freq.merge(word.toLowerCase(), 1L, Long::sum);    });}  
```  

위 코드는 스트림 패러다임을 이해하지 못한 나쁜 코드의 예시이다.  
스트림의 `forEach` 메서드에 전달된 람다는 스트림의 각 단어를 소문자로 변환한 후,  
`freq` 맵에 단어의 빈도수를 기록하는 부작용이 있다. (외부 상태를 변경함)

이러한 코드는 스트림의 장점을 살리지 못할 뿐더러, 병렬 스트림으로 변경할 경우 동기화 문제도 발생할 수 있다.

```java  
// 스트림을 제대로 활용하기  
Map<String, Long> freq;  
try (Stream<String> words = new Scanner(file).tokens()) {  
    freq = words        .map(String::toLowerCase)        .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));}  
```  

위 나쁜 예시 코드와 같은 일을 하지만, 이번엔 스트림 API를 제대로 사용했다.

책에서는 `forEach` 연산은 스트림 계산 결과를 보고(출력)할 때만 사용하라고 권고한다.  
또한, `forEach`를 사용하면 병렬처리의 이점도 사라지기 때문에 주의해야 한다.

스트림을 제대로 활용한 코드는 `collector`를 사용하는데, 스트림을 사용하려면 꼭 배워야하는 개념이다.

## collector
`java.util.stream.Collectors` 유틸리티 클래스는 자주 사용하는 `Collector` 구현체를 제공한다.  
메서드 또한 집필기준 39개나 가지고 있다.

이를 간단히 설명하면, 축소 전략을 캡슐화한 블랙박스 객체이다.
- 블랙박스 객체 : 안에서는 무슨 일이 일어나는지 알 필요 없고, 그냥 입력 결과가 툭 나오는 상자를 의미

> 축소란?  
> 스트림의 원소들을 객체 하나에 취합한다는 뜻이다.  
> 수집기가 생성하는 객체는 일반적으로 컬렉션이며,   
> 그래서 `collector` 라고 부른다.

`collector` 를 사용하면 스트림의 원소를 쉽게 컬렉션으로 모을 수 있다.
- `toList()`
- `toSet()`
- `toCollection(collectionFactory)`


## Collect를 활용한 스트림 파이프라인
```java  
List<String> topTen = freq.keySet().stream()  
    .sorted(Comparator.comparing(freq::get).reversed())    .limit(10)    .collect(toList()); // 자바 16 이상부터는 Collectors.toList() 대신 toList() 사용 가능  
```  
위 코드는 단어 빈도 맵 `freq`에서 가장 빈도가 높은 10개의 단어를 뽑아 리스트로 반환하는 스트림 파이프라인이다.
- `freq.keySet().stream()` : 맵의 키 집합에서 스트림을 생성
- `sorted(Comparator.comparing(freq::get).reversed())` : 맵의 키를 하나씩 받아서 대응하는 단어의 빈도수를 기준으로 내림차순 정렬
- `limit(10)` : 상위 10개 단어로 스트림을 제한
- `collect(toList())` : 최종 결과를 리스트로 수집

### Collectors는 Map으로 수집하는 다양한 메서드를 제공한다.

```java  
private static final Map<String, Operation> stringToEnum =  
    Stream.of(values()).collect(       toMap(Object::toString, e -> e));  
```  
스트림과 컬렉터를 이용한 가장 간단한 맵 수집 예시이다.  
하지만 `toMap` 메서드는 키가 중복될 경우 `IllegalStateException`을 던지기 때문에 주의해야 한다.

키 중복 문제를 해결하기 위해 더 복잡한 형태의 `toMap` 메서드를 사용할 수 있다.  
`groupingBy` 메서드는 키가 중복될 경우 값을 리스트로 모아주기에 충돌을 다루기에 좋다.  
또한, `BinaryOperator<U>` 병합 함수를 제공하여 충돌 해결 전략을 직접 구현할 수도 있다.

인수 3개를 받는 toMap을 사용하면 어떤 키와 그 키에 연관된 원소들 중 하나를 골라  
연관 짓는 맵을 만들 때 유용하게 사용할 수 있다.  
다양한 음악가의 앨범들을 담은 스트림을 가지고, 음악가와 그 음악가의 베스트 앨범을  
연관 짓고 싶은 경우 아래와 같이 작성할 수 있다.

```java  
Map<Artist, Album> topHits = albums.stream().collect(  
    toMap(Album::artist, a->a, maxBy(comparing(Album::sales))));  
```  
첫 번째 인자 : KeyMapper - 맵의 키를 추출하는 함수  
두 번째 인자 : ValueMapper - 맵의 값을 추출하는 함수  
세 번째 인자 : MergeFunction - 키가 중복될 경우 값을 병합하는 함수

현재 스트림의 객체는 Album 타입이고 해당 객체의 아티스트가 키가 된다.
다음 값을 의미하는 두번째 인자에서 `a -> a` 스트림 자기 자신을 의미하기에
`Album`이 된다.
마지막으로 세번째 병합 함수 값을 기반으로 병합한다.

- 충돌이 발생한다면 마지막에 쓴 값을 사용하는 방법
  `toMap(keyMapper, valueMapper, (oldVal, newVal) -> new Val)`

- Collectors가 제공하는 `groupingBy`
  이 메서드는 입력으로 분류 함수를 받고 출력으로는 원소들을 카테고리 별로 모아 놓은 맵을 담은 `collect`를 반환한다.
  분류 함수는 입력받은 원소가 속하는 카테고리를 반환한다. 그리고 이 카테고리가 해당 원소의 맵 키로 쓰인다.
  `words.collect(groupingBy(word -> alphabetize(word))`
  아나그램 을 통해 알파벳화한 단어를 알파벳화한 결과가 같은 단어들의 리스트로 매핑하는 맵을 생성한다.

### 결론
스트림 파이프라인 프로그래밍의 핵심은 부작용 없는 함수 객체에 있다고 한다.

스트림뿐  아니라 스트림 관련 객체에 건네지는 모든 함수 객체가 부작용이 없어야 한다.

이를 위해서는 forEach를 사용할 때는 출력할 때만 이용하고 계산 자체에는 이용하지말자!

또한, 올바로 사용하기 위해서는 Collectors를 잘 알아둬야 한다.

`toList` , `toSet`, `toMap`, `groupingBy`, `joining`
