# 적시에 방어적 복사본을 만들라

자바는 다른 언어들에 비해 메모리 충돌 오류에서 안전하다. 또한 자바로 작성한 클래스는 시스템의 다른 부분에서 변경을 시도해도 그 불변식이 지켜진다.

하지만 아무리 자바라고 해도  다른 클래스로부터의 침범을 아무런 노력 없이는 다 막을 수 없다.
이때문에 **클라이언트(객체를 사용하는 주체)가 내가 작성한 클래스의 인스턴스의 불변식을 깨뜨리려 혈안이 되어 있다고 가정하고 방어적으로 작성**해야한다.

### 어떤 객체든 그 객체의 허락 없이 외부에서 내부를 수정하는 일은 불가능하다.
하지만 조심하지 않으면 아래와 같은 문제가 발생할 수 있다.

```java
public final class Period {
	private final Date start;
	private final Date end;
	
	public Period(Date start, Date end) {
		if (start.compareTo(end) > 0) {
			throw new IllegalArgumentException(start + "가" + end + "보다 늦다.");
			this.start = start;
            this.end = end;
		}
	}
    
    public Date start() {
		return start;
    }
	
	public Date end() {
		return end;
    }
}
```

얼핏 보면 final 필드와 final 클래스 덕분에 `Period` 클래스는 불변인 것처럼 보이고 유효성 검사 또한 잘 이루어지는 것 같다.

하지만 `Date` 클래스는 가변 클래스이기 때문에 클라이언트가 `Period` 객체의 불변식을 깨뜨릴 수 있다.

```java
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
end.setYear(78); // p의 불변식이 깨졌다!
```

위와 같은 방식으로 참조형 필드를 통해 내부 상태가 바뀔 수 있다.

이를 막기 위해서는 **방어적 복사본을 만들어야 한다.**

```java
public Period(Date start, Date end) {
	// 원본은 유지하고 새로운 객체를 반환한다.
	this.start = new Date(start.getTime()); // 새로운 Date 객체 생성
	this.end = new Date(end.getTime());
    if (start.compareTo(end) > 0) {
		throw new IllegalArgumentException(start + "가" + end + "보다 늦다.");
	}
}
```
위 코드에서는 두가지를 기억하자
1. 멀티스레드 환경에서 원본 객체의 유효성 검사를 수행하는 중 원본 객체가 다른 스레드에서 변경될 수 있다.
   따라서 유효성 검사를 수행하기 전에 복사본을 만들어야 한다.
2. 방어적 복사본을 만들 때는 얕은 복사가 아닌 깊은 복사를 해야 한다.

### 방어적 복사를 할 때는 clone() 메서드를 사용하지 말자
`java.util.Date` 클래스는 `final` 타입이 아니다.

따라서 누구나 `Date` 를 상속받아 악성 하위 클래스를 만들 수 있게된다.
악성 하위 클래스를 만들어서 Date의 불변성을 깨뜨릴 수 있다.


```java
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
p.end().setYear(78); // end()가 반환하는건 Period의 내부 참조를 가리킨다.
```

위와 같은 방식으로 `Period` 객체의 불변식이 깨질 수 있다.
따라서 getter 메서드에서도 방어적 복사본을 반환해야 한다.

```java
public Date end() {
    return new Date(end.getTime()); // 새로운 Date 객체 반환
}
```

이렇게 참조값을 다루는 경우 조심해야한다.

특히 내부에서 사용하는 배열(참조 값)을 클라이언트에 반환할 때는 반드시 복사본을 반환해야 한다.
대안으로 배열의 불변 뷰를 반환하는 대안도 있다.

하지만 방어적 복사를 사용하면 안정성은 올라가지만 성능 저하가 따르기에 항상 쓸 수 있는것은 아니다.

어떠한 상황인지 잘 판단하고 적절히 사용하자.
방어적 복사를 생략하는 경우에도 문서화를 통해 클라이언트에게 알려 혹시 모를 위험을 줄이자.

### 요약
- 가변 객체를 참조하는 필드를 가진 클래스는 방어적 복사본을 만들어야 한다.
- getter 메서드로 내부 가변 객체를 반환할 때도 방어적 복사본을 반환해야 한다.
- final이 아닌 클래스의 방어적 복사본을 만들 때는 clone() 메서드를 사용하지 말자.
- 방어적 복사는 성능 저하를 일으키므로 상황에 맞게 적절히 사용하자.
- 방어적 복사를 생략하는 경우에는 문서화를 통해 클라이언트에게 알려주자.
- 불변 객체를 사용하자
