# 30 - 이왕이면 제네릭 메서드로 만들라

```java
// 로 타입 메서드
public static Set union(Set s1, Set s2) {
    Set result = new HashSet(s1);
    result.addAll(s2);
    return result;
}

// 제네릭 메서드
public static <E> Set<E> union(Set<E> s1, Set<E> se) {
	Set<E> result = new HashSet<>(s1);
	result.addAll(s2);
	return result;
}
```

로 타입 메서드와 제네릭 메서드를 보면 타입 매개변수의 유무로 비교할 수 있다
인텔리제이를 사용하는 경우 로 타입을 사용한 메서드는 우측 상단에서 Waring alert를 확인할 수 있다.

**[로 타입 문제점]**

반환 타입이 그냥 `Set`이라서, 컴파일러는 이게 `String`인지 `Integer`인지 모른다. 개발자가 실수로 형변환을 잘못하면 런타임에 `ClassCastException`이 터지고 서버가 오류가 발생한다.

**이러한 문제를 해결하기 위해서 제네릭 메서드를 사용해 타입 안전성을 보장하자!**

하지만 현재 위 예시에서 작성한 제네릭 메서드는 `union()` 하고자 하는 집합이 모두 동일한 타입을 가져야 하기에 유연하지 못하다. - 불공변

조금 더 자세한 예시를 들어보자

```java
Set<Integer> integers = Set.of(1, 3, 5);
Set<Double>  doubles  = Set.of(2.2, 4.4);

// 일반적인 생각 : 합치면 Number 집합이 되겠지?
// 현실: 컴파일 에러 발생! 🚨
Set<Number> numbers = union(integers, doubles);
```

`Integer` 는 `Number` 클래스와 부모 - 자식  관계가 맞다.

하지만 제네릭은 기본적으로 불공변이기 때문에 `Set<Integer>`는 `Set<Number>`의 하위 타입이 아닙니다

그래서 기존 제네릭 메서드인 `union()` 는 이러한 관계를 이해하지 못하고 컴파일 오류를 발생시킨다.

이러한 문제를 해결하기 위해서는 아이템 31에서 나오는 한정적 와일드카드 타입을 사용하여 더 유연하게 개선할수 있다.

### 싱글턴 팩터리  - 불변 객체를 여러 타입으로 활용하는 경우

제네릭의 런타임에 타입 정보가 소거된다는 점을 이용해 하나의 객체를 어떤 타입으로든 매개변수화 할 수 있다.

```java
public static final <T> Set<T> emptySet() {
    return (Set<T>) EMPTY_SET;
}

public static final Set EMPTY_SET = new EmptySet<>();

```

`emptySet()`  과 같은 비어있는 자료구조를 반환 받는 경우에는 제네릭 마다 항상 `new EmptySet<>();` 을 사용하는 게 아니라 싱글턴 방식으로 불변 객체를 만들어두고 형변환만 적용하여 메모리 효율성을 높이는 것을 볼 수 있다. (만약 비어있는 Set이 아닌 경우 `get()` 호출 시 ClassCastException 오류 발생 가능성이 있지만 비어있는 상태라 발생 가능성은 0% 이다.)

제네릭은 런타임에 타입 정보가 사라지기 때문에, 상태가 없는(비어있는) 불변 객체라면 싱글턴 하나만 만들어놓고 형변환만 해서 여러 타입으로 돌려써도 안전하다. 이걸 **제네릭 싱글턴 팩터리**라고 부른다.

또한, 항등함수와 같이 입력 값을 수정 없이 그대로 반환하는 특징을 가진 항등함수인 경우 `T` 가 어떤 타입이든 다시 변환할 수 있다는 것을 보장할 수있다.

### 재귀적 타입 한정

자기 자신이 들어간 표현식을 사용하여 타입 매개변수의 허용 범위를 한정할 수 있다.

재귀적 타입 한정은 주로 타입의 순서를 정하는 `Comparable` 인터페이스와 함께 쓰인다.

```java
public interface Comparable<T> {
	int compareTo(T o);
}
```

여기서 타입 매개변수 `T` 는 `Comparable<T>` 를 구현한 타입이 비교할 수 있는 원소의 타입을 정의한다.

한번 더 풀어서 써보면 Comparable를 구현하는 클래스가 비교하고 싶은 원소의 타입을 지정하라는 것이다.

이 때 거의 모든 타입은 아래와 같이 자신과 같은 타입의 원소와만 비교한다.

```java
class Node implements Comparable<Node> {
    int value;

    public Node(int value) {
        this.value = value;
    }

    @Override
    public int compareTo(Node o) {
        return Integer.compare(this.value, o.value);
    }
}
```

이렇게 `Comparable` 를 구현한 원소의 **컬렉션**을 입력받는 메서드들은 주로 그 원소들을 정렬하거나 최대,최소 값을 구하기 위해 사용된다.

이를 위해 컬렉션에 담긴 모든 원소가 상호 비교될 수 있어야 한고 여기에 **재귀적 타입 한정 방법을 활용**한다.

```java
public static <E extends Comparable<E>> E max(Collection<E> c);
```

타입 한정인 `<E extends Comparable<E>>` 는 모든 타입 `E` 는 자신과 비교할 수 있다.

라고 읽을 수 있다.

### 결론

위에서 정리했던 내용은 로 타입 보다는 제네릭 메서드를 사용하는 것이 타입 안정성을 보장하고 런타임 에러 보다는 컴파일 에러를 보장할 수 있다는 것을 알 수 있었다.

또한 단순히 제네릭 메서드를 도입해서 사용하는 것이 아닌 제네릭 싱글턴 팩터리 방식와 재귀적 타입 한정 방식을 사용하면 더 효과적으로 사용할 수 있었다.

싱글턴 팩터리 방식의 경우 제네릭 소거 방식을 기반으로 불변, 항등함수등을 취급하는 제네릭 메서드의 메모리 효율성과 성능 개선을 할 수 있었다.

재귀적 타입 한정 방식의 경우 타입 매개변수(`T`, `E` …) 의 타입을 보장하여 안정성을 높일 수 있고 이를 `Collections`  에서 활용하며 원소의 대소 비교를 어떻게 런타임 오류 없이할 수 있는지 알아보았다.