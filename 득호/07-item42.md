# 익명 클래스보다는 람다를 사용하라


### 익명 클래스란?
```java
Collections.sort(words, new Comparator<String>() {)  
    @Override    
    public int compare(String s1, String s2) {        
	    return Integer.compare(s1.length(), s2.length());    
    }
};
```

위와 같이 정렬을 위한 `Comparator<String>` 인터페이스를 사용하기 위해서 `compare()` 메서드를 재정의 해야하는데 이를 정렬 시점에 정의하는 것을 말한다.

하지만 익명 클래스 방식은 너무 길기 때문에 자바는 함수형 프로그래밍에 적합하지 않았다.

자바 8부터는 추상 메서드 하나짜리 인터페이스는 특별한 의미를 인정받아 특별 대우를 받게된다.
지금은 함수형 인터페이스라 부르고 이 인터페이스들의 인스턴스를 `람다식`을  사용해 만들 수 있게 됐다.

### 람다식을 함수 객체로 사용
```java
Collections.sort(words,
		(s1, s2) -> Integer.compare(s1.length(), s2.length()));
```

위에서 익명클래스를 사용한 것 에 비해 매우 간결한 모습이다.
여기서 람다, 매개변수 (s1, s2), 반환값의 타입은 각각 `(Comparator<String>)`,   `String` , `int` 지만 코드에서는 언급이 없다.

- 컴파일러가 대신해서 문맥을 살펴 타입을 추론한다.
- 컴파일러가 추론하지 못하는 경우 직접 명시해야 한다.
- **타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다의 모든 매개변수 타입은 생략하자**

>  아이템 26에서는 제네릭의 로 타입을 쓰지 말라  했고, 아이템 29에서는 제네릭을 쓰라 했고, 아이템 30에서는 제네릭 메서드를 쓰라고 했다. 이 조언들은 람다식에서 컴파일러가 타입을 추론할 때 정보를 제네릭에서 추출하기에 도움을 준다.
>
>  만약 위 람다 예시 코드에서  words 가 `List<String>` 이 아니라 로 타입인 `List` 였다면 컴파일 오류가 발생했을 것이다.



### 람다 자리에 비교자 메서드 사용하기

비교자 생성 메서드를 사용하면 코드를 더 간결하게 사용할 수 있다.
```java
Collections.sort(words, comparingInt(String::length));
```


더 나아가 자바 8 때 `List` 인터페이스에 추가된 sort 메서드를 활용하면 더 간단해 진다.
```java
words.sort(comparingInt(String::length));
```

람다를 언어 차원에서 지원하면서 적합하지 않았던 곳에서도 함수 객체를 실용적으로 사용할  수 있게 됐다.

### 아이템 34의 Operation 열거타입 람다 적용

```java
    public enum Operation {
        PLUS("+") {public double apply(double x, double y) { return x + y; }},
        MINUS("-") {public double apply(double x, double y) { return x - y; }},
        TIMES("*") {public double apply(double x, double y) { return x * y; }},
        DIVIDE("/") {public double apply(double x, double y) { return x / y; }};
        
        private final String symbol;
        
        Operation(String symbol) {
            this.symbol = symbol;
        }
        public abstract double apply(double x, double y);
    }
```
람다를 사용하면 위 코드를 다음과 같이 간결하게 만들 수 있다.

```java
    public enum Operation {
        PLUS("+", (x, y) -> x + y),
        MINUS("-", (x, y) -> x - y),
        TIMES("*", (x, y) -> x * y),
        DIVIDE("/", (x, y) -> x / y);
        
        private final String symbol;
        private final DoubleBinaryOperator op;
        
        Operation(String symbol, DoubleBinaryOperator op) {
            this.symbol = symbol;
            this.op = op;
        }
        
        public double apply(double x, double y) {
            return op.applyAsDouble(x, y);
        }
    }
```

람다를 사용하기 위해서는 함수형 인터페이스가 필요하다.
위 예시에서는 `java.util.function` 패키지가 제공하는 `DoubleBinaryOperator` 함수형 인터페이스를 사용했다.

이는 double 타입 매개변수 2개를 받아 double 타입 결과를 돌려준다.

### 상수별 클래스 바디는 필요없는가?
람다의 사용법과 간결성을 보면서 상수별 클래스 바디는 더이상 사용할 이유가 없다고 느낄지도 모른다.
충분히 매력적인 대안이지만 상수별 클래스 바디가 더 적합한 경우도 있다.

- 람다는 이름이 없고 문서화도 못한다.
  따라서 코드 자체 가독성이 떨어질 수 있고, 이를 모르는 사용자들에겐 낯설게 느껴질 수 있다.

- 람다는 한줄일 때 가장 좋고 길어야 세 줄 안에 끝내는게 좋다고 한다. 
  세줄이 넘어가면 가독성이 심하게 나빠진다.
  람다가 길거나 읽기 어렵다면 더 간단히 줄여보거나 람다를 쓰지 않는 쪽으로 리팩터링을 추천한다.

- 람다는 추상 클래스의 인스턴스를 만들 때 쓸 수 없다.
- 람다는 자기 자신을 참조할 수 없다. 
  람다에서 this를 사용하면 바깥 인스턴스를 가리킨다. (익명클래스는 익명 클래스 인스턴스를 가리킨다.)
- 람다도 익명 클래스처럼 직렬화 형태가 구현별로 다를 수 있다.
  따라서 람다를 직렬화 하는 일은 피하는 게 좋다.