### 로 타입이란?

제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. `List<E>`의 로 타입은 `List`다.

로 타입은 타입 선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작하는데, 제네릭이 도입되기 전 코드와 호환되도록 하기 위해 어쩔 수 없이 만들어진 최선책이다.

제네릭을 지원하기 전에는 컬렉션을 다음과 같이 선언했다.

```java
// Stamp 인스턴스만 취급한다는 의도
private final Collection stamps = ...;
```

위 코드를 작성한 개발자의 의도는 Stamp 객체만 취급하고 싶었지만, 다른 객체를 넣어도 오류가 발생하지 않고 정상 컴파일되고 실행된다.

```java
for (Iterator i = stamps.iterator(); i.hasNext(); ) {
    Stamp stamp = (Stamp) i.next(); // ClassCastException 발생!
    stamp.cancel();
}
```

이러한 상황은 컴파일 시점에는 문제가 발생하지 않지만 런타임 시 오류를 유발하기에 이후 문제를 해결하는 데 어려움을 준다.

하지만 제네릭을 사용하면 이런 정보가 주석이 아닌 타입 선언 자체에 녹아든다.

```java
private final Collection<Stamp> stamps = ...;
```

제네릭을 통해 컴파일 시점에 어떠한 인스턴스를 취급하는지 알 수 있고 조기에 오류를 식별할 수 있다. 컴파일러는 컬렉션에서 원소를 꺼내는 모든 곳에 보이지 않는 형변환을 추가하여 절대 실패하지 않음을 보장한다.

> 🚨로 타입을 쓰면 제네릭이 안겨주는 안정성과 표현력을 모두 잃게 된다.
>

절대 사용하지 않는 것을 권장하지만 아직도 로 타입을 사용할 수 있는 이유는 제네릭이 등장하기까지 10년이 걸렸고, 그 전 자바 코드들과 맞물려 돌아가게 하기 위함이다.

---

### List 같은 로 타입은 사용해서는 안 되나, List<Object>는 괜찮다

`List`와 `List<Object>`가 동일하게 보일 수 있다. 하지만 큰 차이가 있다.

- `List`는 제네릭 타입 시스템에서 완전히 이탈한 상태다
- `List<Object>`는 모든 타입을 허용한다는 의사를 컴파일러에게 명시적으로 알린다

```java
// 로 타입 사용 → 런타임 오류 발생
public static void main(String[] args) {
    List<String> strings = new ArrayList<>();
    unsafeAdd(strings, Integer.valueOf(42));
    String s = strings.get(0); // ClassCastException 발생!
}

private static void unsafeAdd(List list, Object o) {
    list.add(o); // 컴파일러가 막지 못함
}
```

```java
// List<Object> 사용 → 컴파일 오류 발생
public static void main(String[] args) {
    List<String> strings = new ArrayList<>();
    unsafeAdd(strings, Integer.valueOf(42)); // 컴파일 에러!
    String s = strings.get(0);
}

private static void unsafeAdd(List<Object> list, Object o) {
    list.add(o);
}
```

두 번째 예제가 컴파일 에러가 나는 이유는 `List<String>`이 `List<Object>`의 하위 타입이 아니기 때문이다. 제네릭은 **불공변**이라서 `List<String>`을 `List<Object>` 파라미터에 **전달할 수 없다.**

---

### 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 와일드카드 `?`를 사용하자

로 타입은 내부 원소가 무엇이 오든지 신경쓰지 않지만, 타입 안정성을 컴파일 시점에 보장할 수 없다는 단점이 존재한다.

```java
// 로 타입 사용 (위험!)
static int numElementsInCommon(Set s1, Set s2) {
    s1.add("스트링 값"); // 실수로 넣어도 컴파일러가 막지 못함
    
    int count = 0;
    for (Object o1 : s1) {
        if (s2.contains(o1)) count++;
    }
    return count;
}

public static void main(String[] args) {
    Set<Integer> numbers = new HashSet<>();
    numbers.add(1);
    
    // numbers는 Integer만 담기로 약속했는데, 
    // 메서드 안에서 String이 들어가버림!
    numElementsInCommon(numbers, new HashSet<>());
    
    for (Integer n : numbers) { // ClassCastException 발생!
        System.out.println(n);
    }
}
```

와일드카드 `?`를 사용하면 위와 같은 상황을 방지할 수 있다.

```java
// 비한정적 와일드카드 사용 (안전!)
static int numElementsInCommon(Set<?> s1, Set<?> s2) {
    s1.add("스트링 값"); // 컴파일 에러! null 외에는 넣을 수 없음
    
    int count = 0;
    for (Object o1 : s1) {
        if (s2.contains(o1)) count++;
    }
    return count;
}
```

`Set<?>`와 `Set`의 차이점은 명확하다. 와일드카드 타입은 안전하고, 로 타입은 안전하지 않다. 로 타입 컬렉션에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉽다. 반면 `Collection<?>`에는 `null` 외에는 어떤 원소도 넣을 수 없어서 컬렉션의 타입 불변식을 보호할 수 있다.

---

## 로 타입을 써야 하는 예외 상황

### 1. class 리터럴에는 로 타입을 써야 한다

자바 명세는 class 리터럴에 매개변수화 타입을 사용하지 못하게 했다.

**허용:**

- `List.class`
- `String[].class`
- `int.class`

**불가능:**

- `List<String>.class`
- `List<?>.class`

매개변수화 타입이 있는 경우 class 리터럴을 사용하지 못하는 이유는 **타입 소거(type erasure)**와 모순이 발생하기 때문이다.

컴파일 타임에 `List<String>`과 `List<Integer>`를 구분한다. 하지만 런타임엔 타입 소거로 인해 오직 `List`라는 로 타입만 남게 된다. 만약 `List<String>.class`를 허용한다는 건, 메모리에 타입 소거가 되지 않은 `List<String>`이라는 클래스가 따로 존재한다는 의미가 되기 때문에 논리적 모순이다.

### 2. instanceof 연산자

런타임에는 제네릭 타입 정보가 지워지므로 `instanceof` 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없다.

```java
// 컴파일 에러!
if (o instanceof List<String>) { ... }
```

**로 타입으로 써도 좋은 예:**

```java
if (o instanceof Set) {       // 로 타입으로 검사
    Set<?> s = (Set<?>) o;    // 와일드카드 타입으로 형변환
    ...
}
```

`o`의 타입이 `Set`임을 확인한 다음 와일드카드 타입인 `Set<?>`로 형변환하는 좋은 예시이다. 이는 검사 형변환(checked cast)이므로 컴파일러 경고가 발생하지 않는다.

---

## 결론

로 타입을 사용하면 런타임에 예외가 발생할 수 있으니 사용하면 안 된다. 로 타입이 아직 존재하는 이유는 제네릭이 자바 5에서 늦게 등장하여 호환성을 위해 남아 있는 것이다. 컴파일 시점에 오류를 잡아 안정적으로 운영하고 싶다면 제네릭 사용을 적극적으로 활용하자.