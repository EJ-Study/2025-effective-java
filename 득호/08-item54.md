# null이 아닌, 빈 컬렉션이나 배열을 반환하라

```java
// 따라하지 말 것
/**
 * return 매장 안의 모든 치즈 목록을 반환한다.
 *  만약, 치즈가 하나도 없다면 null을 반환한다.
 */

public List<Cheese> getCheeses() {
	return cheesesInStock.isEmpty() ? null
        : new ArrayList<>(cheesesInStock);
}
```

위 코드는 따라하지 말아야 할 예제다.
치즈가 없다고 한들 이를 특별 취급하여 null을 반환할 이유가 없다.

Null을 반환함으로써 얻는 이점은 아무것도 없고 오히려 `NullPointerException`을 유발할 위험만 커진다.

이 문제를 해결하기 위해서는 해당 메서드를 사용하는 클라이언트 측에서 방어 코드를 넣어줘야하는 불편함이 생긴다.

```java
List<Cheese> cheese = shop.getCheeses();
if (cheese != null) && cheeses.contains(Cheese.STILTON)) {
	//...
    } 
    
```
이렇게 클라이언트에서 null 가능성을 고려해서 코드를 작성해야 한다.
null을 반환할 가능성이 없는 메서드를 사용하면 작성하지 않아도 되는 코드인셈이다.

또한, 해당 메서드를 여러 곳에서 사용한다면 쓸모 없는 코드는 더 증가하기에 그리 좋지 않는 방법같다.

### Null 대신 빈 컬렉션이나 배열을 반환하자 

```java
public List<Cheese> getCheeses() {
     return new ArrayList<>(cheeesesInStock);
}
```

이제 `getCheeses()` 를 사용하면서 NullPointerException이 발생할 위험이 사라졌다.
하지만 가능성은 작지만 사용 패턴에 따라 빈 컬렉션 할당이 성능을 저하시킬 수 있다.

이를 **최적화하기 위해서 앞 item17에서도 나왔듯이 불변 빈 컬렉션을 재활용 하자** 

### 길이가 0일 수도 있는 배열을 반환하는 올바른 방법
```java
private static final Cheese[] EMPTY_CHEESE_ARRAY = new Cheese[0];
public Cheese[] getCheeses() {
    return cheesesInStock.toArray(EMPTY_CHEESE_ARRAY);
}
```
위 코드를 보면서 오잉? 이렇게 하면 항상 빈 배열을 반환하는거 아니야? 라고 생각할 수 있다.

사실 내가 그랬다...

> 🧙‍♂️ toArray의 내부 로직
>toArray(T[] a) 메서드는 들어온 배열 a를 보고 이렇게 판단한다.
>
>"야, 내가 가진 데이터(List) 크기랑 네가 준 배열(a) 크기랑 비교 좀 해보자."
>
>상황 ①: 리스트에 데이터가 있을 때 (예: 치즈 3개)
>비교: "내 데이터는 3개인데, 네가 준 배열(EMPTY_CHEESE_ARRAY)은 크기가 0이네?"
>
>판단: "이 배열엔 다 못 담아. 내가 알아서 크기 3짜리 새 배열을 만들어서 담아줄게."
>
>결과: Cheese[3] (데이터 3개가 꽉 찬 새로운 배열 반환)
>
>상황 ②: 리스트가 비어있을 때 (데이터 0개)
>비교: "나도 비어있고, 네가 준 배열도 비어있네?"
>
>판단: "그럼 굳이 새로 만들 필요 없이, 네가 준 거 그냥 그대로 돌려줄게."
>
>결과: EMPTY_CHEESE_ARRAY (메모리 아끼고 그대로 반환)


### 결론
null이 아닌, 빈 배열이나 컬렉션을 반환하라. null을 반환하는 API는 사용하기 어렵고 오류 처리 코드도 늘어난다.
**그렇다고 성능이 좋은 것도 아니다.** 
