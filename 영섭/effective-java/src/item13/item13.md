# clone 재정의는 주의해서 진행하라

## 문제점

Cloneable은 복제해도 되는 클래스임을 명시하는 인터페이스지만, 실제로는 clone() 메서드가 Object 클래스에 protected로 선언되어 있어 이상하게 동작

**clone() 메서드의 일반 규약**

- x.clone() ≠ x (복사본과 원본은 다른 객체)
- x.clone().getClass() == x.getClass() (같은 타입)
- x.clone().equals(x) (논리적으로 동등할 수 있음, 필수는 아님)

## 주의사항

1. **가변 객체 참조 문제**: 단순히 super.clone()만 호출하면 얕은 복사가 되어 원본과 복사본이 같은 객체를 참조
2. **재귀적 복사 필요**: 배열, 리스트 등 가변 객체를 필드로 가진 경우 깊은 복사를 해야 함
3. **final 필드와 충돌**: clone 방식은 final 필드 사용과 충돌할 수 있음
4. **스레드 안전성**: clone() 메서드도 동기화가 필요할 수 있음

## 권장 사항

- **복사 생성자나 복사 팩터리를 사용**하는 것이 더 나은 대안
- 배열 복사에는 clone()이 적합하지만, 일반적으로는 사용을 지양
- 상속용 클래스는 Cloneable을 구현하지 않는 것이 좋음

## 대안

```java
// 복사 생성자
public Yum(Yum yum) { ... }

// 복사 팩터리
public static Yum newInstance(Yum yum) { ... }
```

이 방식들이 clone()보다 더 안전하고 유연하며 명확함