# 인스턴스를 막으려거든 private 생성자를 사용하라

## 왜 인스턴스화를 막아야 하는가?

- 정적 메서드와 정적 필드만을 담은 유틸리티 클래스의 경우
- 예시: `java.lang.Math`, `java.util.Arrays`, `java.util.Collections`
- 위와 같은 클래스는 인스턴스로 만들어 쓰려고 설계한 게 아님

## 추상 클래스로는 불가능한 이유

- 추상 클래스를 만들어도 하위 클래스를 만들어 인스턴스화 가능
- 사용자가 상속해서 쓰라는 오해를 불러일으킬 수 있음

## private 생성자를 통해 해결

```java
public class UtilityClass {
    // 기본 생성자가 만들어지는 것을 막는다(인스턴스화 방지용)
    private UtilityClass() {
        throw new AssertionError();
    }
    
    // 나머지 코드 생략
}
```

## 장단점

- **장점**: 상속 불가능 (모든 생성자는 상위 클래스의 생성자를 호출해야 하는데 private이라 호출 불가)
- **단점**: 생성자가 있는데 호출할 수 없어서 직관적이지 않음 → 주석으로 설명 필요